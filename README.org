* DESim: Discrete Event based Simulation

This is a new clean repository where I will be building up a discrete
event simulation package, using design decisions reached in other
rather more cluttered repositories. My goal is to create a framework
that enables signal-accurate cycle-accurate simulations of the digital
computers from fifty years ago, but to avoid having anything in the
framework that is inherently specific to any particular simulated
system beyond the fundamental scope of the project

** Discrete, not Continuous

The simulation proceeds by evaluating portions of the system at
discrete times, and no provision is made for tracking what happens
between the ticks of the simulation.

*** Action: a bit of code that runs

At the core of this facility is a first-in first-out queue of bits of
code to be evaluated at the current time, and a bit of code specific
to the simulation that owns the definition of the current time, which
takes care of advancing the simuilated time and kicking off the
activity for the next time.

*** Actions: a queue of bits of code to run

The bits of code may be wraped in an Action, and there is an Actions
facility that handles a first-in-first-out collection of these.

** Digital, not Analog

Values managed by this simulation are digital in nature. The
fundamental unit of storage is the Bit, which can be 0 or 1. To
simplify simulation of systems that inherently cluster Bits as a
binary number (such as the Address and Data busses in most
processors), some values may take on an unsigned 8-bit, 16-bit, or
larger value. Accordingly, simulations will tend to provide larger
data types such as Byte and Word.

** Modules and Signals

The abstraction being simulated comprises a collection of Modules, and
a collection of Signals. This is nothing new or significant, and in
fact this section exists only to commit to using those specific names.

Signals are the mechanism used by Modules to communicate. Modules may
publish values onto signals, and may observe the value of signals.

*** Bus Signals

Some signals merely contain the most recent value set by a module,
which other modules can observe (often done within edge-triggered code
connected to a proper Edge signal).

It is expected that Bus Signals will appear in the system merely as
bare storage in the owning module, and pointers back to that storage
in other modules with access to the signal.

*** Edge Signals

Some signals allow "edge triggered" semantics. Modules may, during
initialization, specify some code to be run on the rising or falling
edge of the signal. The major use case of this is to store a 0 or a 1,
which gives "rising" and "falling" the obvious meaning.

In order to properly service the "edge triggered" semantics, the
storage for the value of the signal is coupled with a list of Action
objects to activate on the rising edge, and a distinct list to
activate on the falling edge.

Note that the list of bits of code to run on an edge is very similar
to the Actions structure mentioned above, except that each Action
is not removed from this list when it has run.
