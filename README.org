* DESim: Discrete Event based Simulation

This is a new clean repository where I will be building up a discrete
event simulation package, using design decisions reached in other
rather more cluttered repositories. My goal is to create a framework
that enables signal-accurate cycle-accurate simulations of the digital
computers from fifty years ago, but to avoid having anything in the
framework that is inherently specific to any particular simulated
system beyond the fundamental scope of the project

** PROJECT DOWNCODE WORK IN PROGRESS

In this branch I once again wipe away the code and start from
scratch, implementing what I have learned from experiments that
depended on C++ classes and lambda expressions.

I think I can do this in C99, and despite all the C++ talk about
zero cost abstractions, I think I can make it faster.

** Digital, not Analog

Values managed by this simulation are digital in nature. The
fundamental unit of storage is the Bit, which can be 0 or 1. To
simplify simulation of systems that inherently cluster Bits as a
binary number (such as the Address and Data busses in most
processors), some values may take on an unsigned 8-bit, 16-bit, or
larger value. Accordingly, simulations are expected to provide larger
data types appropriate to their domain (such as Byte and Word).

** Discrete, not Continuous

The simulation proceeds by evaluating portions of the system at
discrete times, and no provision is made for tracking what happens
between the ticks of the simulation.

** Edge

Objects of type "edge" represent a special signal in the system that
allows code to be notified on rising and falling edges. Each such
object has a current value, a list of functions (each with an
argument) to call after the value increases, and a list of functions
(each with an argument) to call after the value decreases.

** Functions

The fundamental unit of work is a function call that implements some
fragment of logic within the system. These are plain old C functions
that take a pointer to some context, and return nothing.

** Bus Values

These values are plain old C data of an appropriate size, which can be
observed and modified by the various logic functions. Generally, where
the function context represents a functional unit, that structure will
contain storage for busses owned by the unit, or pointers to storage
in other structures that own the data.

** Time

Time is represented by two global variables in the system, both of
which are of type tau_t, which is intended to be a type that can
maintain a monotonically increasing value, without loss of precision,
across the whole span of any useful simulation.

The two variables are TAU and UNIT. TAU represents elapsed simulated
time in some unit useful to the user -- 64-bit unsigned nanoseconds
seems to be suitable for simluation of 50 year old digital logic. UNIT
is expected to increment once for each cycle of the fastest clock in
the system, allowing UNIT to easily be used as an array index when
working with signal trace data for display.

*** ---

** ---
