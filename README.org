* DESim: Discrete Event based Simulation

This is a new clean repository where I will be building up a discrete
event simulation package, using design decisions reached in other
rather more cluttered repositories. My goal is to create a framework
that enables signal-accurate cycle-accurate simulations of the digital
computers from fifty years ago, but to avoid having anything in the
framework that is inherently specific to any particular simulated
system beyond the fundamental scope of the project

** Committed to PROJECT DOWNCODE

The simulation framework, and the 8224 simulation, have been
successfully downcoded to C99 (with GNU extensions). I think that
this project can be done without C++ facilities.

** Unconventional Naming Conventions

Follow the rule: Code in the Language of the Domain.

In the domain of old computers I want to simulate, signals names are
written in UPPERCASE, so I will follow this convention when naming
variables representing the states of signals.

Several years of total immersion in Java has left me actually liking
the idea of using Capitalized words for class names, while still
keeping the C convention of Keep It Short.

Examples:
- UNIT is the time variable, of type Tau.
- CLOCK is the clock signal, of type Edge.
- RSTIN_ is the reset input signal, of type Edge, which is active-low.

** Digital, not Analog

Values managed by this simulation are digital in nature. The
fundamental unit of storage is the Bit, which can be 0 or 1. To
simplify simulation of systems that inherently cluster Bits as a
binary number (such as the Address and Data busses in most
processors), some values may take on an unsigned 8-bit, 16-bit, or
larger value. Accordingly, simulations are expected to provide larger
data types appropriate to their domain (such as Byte and Word).

** Discrete, not Continuous

The simulation proceeds by evaluating portions of the system at
discrete times, and no provision is made for tracking what happens
between the ticks of the simulation.

** Edge

Simulation execution is oriented toward the rising and falling edges
of the signals within the simulated system, and triggering code that
has asked to run on the appropriate edges.

** Functions

The fundamental unit of work is a function call that implements some
fragment of logic within the system. These are plain old C functions
that take a pointer to some context, and return nothing.

** Bus Values

These values are plain old C data of an appropriate size, which can be
observed and modified by the various logic functions. Generally, where
the function context represents a functional unit, that structure will
contain storage for busses owned by the unit, or pointers to storage
in other structures that own the data.

** Time

Time is represented by one global variables in the system, of
type Tau, which is intended to be a type that can
maintain a monotonically increasing value, without loss of precision,
across the whole span of any useful simulation.

This variable is UNIT, and it is incremented by one each time the
clock cycles to the next discrete time.

The Clock package knows the frequency and period, and can be asked
to compute the simulation time in floating point microseconds by
calling the TU macro.

*** ---

** ---

* Core Simulation Modules of Note

** Edge: state, and things to do on rising and falling edges

The module is a direct implementation of the abstraction above. A
structure contains the value, and two expandable lists containing
functions to call and the parameters to pass to them.

Entry points are provided to observe and set the value; slightly
faster methods are provided for "set value to 0" and "to 1".

Callers are free to use (e->value) directly; using the "Edge_get(e)"
method is entirely optional. Edge_get may be converted to a macro in
the future, and using the named function is not substantially more
clear than accessing the state directly.

All operations above are considered Timing Critical and no changes
will be contemplated that increase their runtime.

Additionally, non-time-critical methods are provided for
initialization and for adding subscribers to the callback lists.

Edge objects and their friends presume that each Edge is effectively
immortal. It is an error to construct an Edge on the stack, or to free
a dynamically allocated Edge.

** Clock: a freerunning system timebase

This facility provides "Edge CLOCK;" and presents rising and falling
edges on it at a rate determined by the Clock_init() call. As the
initial collection of non-core simulation modules are centered around
the Intel 8080, evaluations of this code use an 18.00 MHz clock rate,
giving a period of 55 5/9 ns.

The module generates a rising edge on CLOCK, then a falling edge; after
both edges are processed, UNIT is incremented.

Currently there is one and only one Clock, embodied in the CLOCK
signal and in file-local scope data owned by the implementation.

This SINGLETON decision will be revisited if and when desim is applied
to the simulation of a system with multiple asynchronous clocks; this
decision is not taken lightly, and it allows us to avoid placing a
priority queue at the root of the most time critical part of the
simulation engine.

* Support Code of Note

** RTC: real time clock

Benchmarking, Testing, and Development support.

The rtc_ns() function returns the elapsed time in Tau form (which is
an integer number of nanoseconds) since an arbitray epoch. The
intended use is to make two calls, and subtract the return value of
the first from the return value of the second.

** Timing: verify simulated timing of events

This package provides for observing the change-in-UNIT at a recording
event since the last starting event, tracking the range of values
observed, and comparing with the allowed range. Typically the start
and record functions will be called from Edge-triggered code.

Methods for sampling time work with UNIT values for speed; time limits
are specified in nanoseconds.

This is intended to be used by simulation modules to verify that the
timing of the simulated signals is within limits specified in the data
sheet of the simulated item, or of another item intended to consume
the signal.

** Traced: collect and display behavior of signals

Instances of this module attach themselves to a given Edge, watching
as it rises and falls, and provide a textual representation of the
behavior of the signal. If told that a signal is active-low, Traced
can adjust the output appropriately to properly emphasize where the
signal is active.

** Format: arbitrary printf-like formatting

This printf-like function uses =vsnprintf= to construct formatted
output into a dynamically allocated string. The caller is responsible
for freeing the string when it is no longer used.

This is commonly used to format the names of signals that are owned by
a module with a name.

* Non-Core Simulation Modules of Note

** Gen8224: Clock Generator

This simulates the behavior of the Intel 8224 Clock Generator and
Driver for 8080A CPU as described in section 5 of the 8080
Microcomputer Systems Manual published in September 1975.

Note that the behavior described in the 8224 data sheet differs from
the behavior of the 8080 Clock Generator discrete logic provided in
Figure 3-3 in a number of details. Side-by-side study of Fig 3-3 and
the 8224 data sheet is enlightening.

** Ctl8228: System Controller

This simulates the behavior of the Intel 8228 System Controller and
Bus Driver for 808A CPU as described in section 5 of the 8080
Microcomputer Systems Manual published in September 1975.

This simulation differs from the data sheet in how it interfaces to
the Data bus. The simulation system does not require bus drivers, so
there is no division between CPU Data Bus and System Data Bus.

** Dec8080: Address Decode logic

This module provides address space decoding logic.

The decoder can accept connections from ROM and RAM modules
taking ownership of specified pages of memory, where the 64 KiB
address space is divided into 64 pages of 1 KiB each.

** Cpu8080: Single Chip 8-Bit Microprocessor

This simulates the behavior of the Silicon Gate MOS 8080A Single Chip
8-Bit N-Channel Microprocessor as described in section 5 of the 8080
Microcomputer Systems Manual published in September 1975.

The built-in self test for Cpu8080 makes use of the modules above to
construct a small 8080 based system for testing.

This module is currently under development.

The simulation will not attempt to match sufficiently "internal"
aspects of the processor; for example, we will not simulate a number
of internal latches and buffers. The scope of the simulation is to
allow execution of historical 8080 software, along with the ability to
extract waveform diagrams of signals external to the chips.

** Rom8316: Read-Only Memory (1024x8 bits)

This roughly simulates the behavior of an 8316 ROM chip, with some
external logic allowing us to drive this module from a single Chip
Enable representing when DBIN rises with our address range.

The event at /MEMR↓ ("you are addressed") is not yet in the
simulation, as more design needs to be done around how the ROM
gains control to end the WAIT states.

** Ram8107x8: Read-Write Memory (4096x8 bits)

This roughly simulates the behavior of an eight 8107 RAM chips, with
some external logic allowing us to drive this module from a single
Chip Enable representing when DBIN rises with our address range, and a
simple Write Enable that rises when /WR falls with our address range.

The events at /MEMR↓ and /MEMW↓ ("you are addressed") are not yet in
the simulation, as more design needs to be done around how the RAM
gains control to end the WAIT states.

** Future Parts (maybe, maybe not)

*** 8255 Programmable Peripheral Interface

supports 24 i/o pins

*** 8251 Programmable Communication Interface

Serial Port (sync or async)

*** 8205 high speed 1-of-8 decoder

*** 8214 priority interrupt control unit

*** 8216/8226 parallel bidirectional bus driver

*** 8253 programmable interval timer

*** 8257 programmable dma controller

*** 8259 programmable interrupt controller

