* DESim: Discrete Event based Simulation

This is a new clean repository where I will be building up a discrete
event simulation package, using design decisions reached in other
rather more cluttered repositories. My goal is to create a framework
that enables signal-accurate cycle-accurate simulations of the digital
computers from fifty years ago, but to avoid having anything in the
framework that is inherently specific to any particular simulated
system beyond the fundamental scope of the project

** Discrete, not Continuous

The simulation proceeds by evaluating portions of the system at
discrete times, and no provision is made for tracking what happens
between the ticks of the simulation.

*** Actions

The unit of work within the simulation is an Action, which is
expressed as a C++ Lambda expression and a simuilated time at which to
execute it. The lambda expression takes no arguments and returns no
value. The current simulated time is a fundamental truth that is
available globally.

Most actions have delayed consequences, which are achieved by having
code running in the action activate an action with a time in the
future, which applies the consequence. For example, if a module wishes
to place data on a data bus 20ns after a rising edge of a clock, then
it has an action attached to the rising clock edge, which activates an
action to set the data bus at a time 20ns in the future.

The collection of Actions is at the core of the simulation; placing
actions into this collection, and fetching the action with lowest
scheduled time, are expected to be the "hot path" through the code,
and will likely be first on the optimization bench.

** Digital, not Analog

Values managed by this simulation are digital in nature. The
fundamental unit of storage is the Bit, which can be 0 or 1. To
simplify simulation of systems that inherently cluster Bits as a
binary number (such as the Address and Data busses in most
processors), some values may take on an unsigned 8-bit, 16-bit, or
larger value.

Floating point might appear, but only in the context of simplification
of the simulation of a floating point unit. It would represent 32 or
64 bits that the simulated module is using in a simulated floating
point context.

** Modules and Signals

The abstraction being simulated comprises a collection of Modules, and
a collection of Signals. This is nothing new or significant, and in
fact this section exists only to commit to using those specific names.

Signals are the mechanism used by Modules to communicate. Modules may
publish values onto signals, and may observe the value of signals.

*** Bus Signals

Some signals merely contain the most recent value set by a module,
which other modules can observe (often done within edge-triggered code
connected to a proper Edge signal).

*** Edge Signals

Some signals allow "edge triggered" semantics. Modules may, during
initialization, specify some code to be run on the rising or falling
edge of the signal. The major use case of this is to store a 0 or a 1,
which gives "rising" and "falling" the obvious meaning.

***# When Edges Trigger Edges

It is beneficial to specify behavior in a particular case.

If several modules are edge-triggered by a specific signal, and each
of those edge-triggered bits of code could change the value of other
Edge signals, we specify that the bits of code are run BREADTH FIRST
order.

That is, service methods are executed in an order AS IF the act of
changing an edge placed them all on a queue, then ran each one in
queue order; and any activities requested by a service are placed on
the end of the FIFO so that any edge propagation flows out all of the
cascading outputs in parallel, rather than flowing down one path, then
starting the next.

During the cascading forward of edge triggered events, the simulation
is not incrementing the tick counter.

*** Conflicts: Signals that Float

Some signals of width N can take on 2^N values, or can be Floating. If
multiple modules can publish data in a Signal, then each should take
care to set the signal state to Floating before another publishes its
value.

A Bus that may be Floating or may be driven by any of several modules
might be implemented by having the Bus reference the module driving
it; this might be efficiently done by having the Bus represent the
value with a pointer to the storage, in the driving module, of the
data for the bus; a floating bus would be a pointer to data the Bus
owns, representing the bus state that would be observed when it is
floating.

*** Conflicts: Wire-And and Wire-Or Signals are Modules

Some signals comprise N independent bits, which take on a high or low
value when not driven, but have multiple modules that can drive them;
if any module drives any bit to the other value, the other value is
observed by all observers.

This raises the spectre of multiple modules driving a signal, and one
of them releasing it -- the simulation needs a clever way to update
the value of the signal based on all of the other driving modules.

As this requires a bit of code to run when a module de-asserts a
wire-or or wire-and signal, this fits as a Module within this
simulation, which can notice the transition of one input and
re-generate the output properly.

** Level of Detail Unspecified by Framework

Within this framework, it is possible to build a system that simulates
down to the individual gates within a clock generator, requiring ticks
to manage the transitions of whatever signal is oscillating. Or one
might build a system where each tick represents one machine cycle, or
one instruction, or other unit of work appropriate to the application
of the framework.

My initial application, for the moment, is inteded to be a
signal-accurate cycle-accurate simulation of an 8080 based system,
stepping the tick with period 55.555 ns, corresponding to the rising
edges of the primary oscillator from which the two-phase clock is
derived in (for example) the Imsai 8080.
